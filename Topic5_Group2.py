# -*- coding: utf-8 -*-
"""Scratch_pop_density.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ts9iIGns1B9uxmotnxxC0tzK3ig8_iLJ
"""

#!pip install requests
#!pip install beautifulsoup4

import numpy as np
import pandas as pd
import requests
import bs4
import lxml.etree as xml

#-----------------------To read population density---------------------
url3='https://www.indexmundi.com/facts/united-states/quick-facts/texas/population-density#table'
popDensity = pd.read_html(url3)

for cell in popDensity:
  popDensity=cell

popDensity['Value']=np.log(popDensity['Value'])  # make the population dessity in logorithm
popDensity
#popDensity.set_index('County')

"""Transmission rate was estimated with shared source code in journal paper under R environment."""

#-------------To read transmission rate R(t) (3 days rolling)-----------------
import pandas as pd
from datetime import datetime

url_rt3='https://raw.githubusercontent.com/XJQiao/Rt_estimation/master/Rt_3days_Rolling.csv'
rt3=pd.read_csv(url_rt3)
rt3=rt3.rename(columns={'Unnamed: 0': 'Dates'})
rt3=rt3.set_index('Dates')

rt3=rt3.T.copy()
dates = [datetime.strptime(sub, '%Y/%m/%d') for sub in rt3.keys()]  
rt3=rt3.T.copy()
#rt=rt.set_index("Dates")
rt3.index=dates
rt3

#-------------To read transmission rate R(t) (without rolling)-----------------
import pandas as pd
from datetime import datetime

url_rt='https://raw.githubusercontent.com/XJQiao/Rt_estimation/master/Rt_no_Rolling.csv'
rt=pd.read_csv(url_rt)
rt=rt.rename(columns={'Unnamed: 0': 'Dates'})
rt=rt.set_index("Dates")
rt=rt.T.copy()
dates = [datetime.strptime(sub, '%Y/%m/%d') for sub in rt.keys()]  
rt=rt.T.copy()
#rt=rt.set_index("Dates")
rt.index=dates
rt

#-------------------Scatter plots-----------------
import numpy as np
############### Mean of Rt along the whole time series###############
rtM=pd.DataFrame([rt.mean(axis=0).index,rt.mean(axis=0).values])
rtM=rtM.T.copy()
rtM.columns=['County','RtM']
#rtM=rtM.set_index('County')

############### Mean of Rt in Jul and Aug ###############
rtM78=pd.DataFrame([rt.loc['2020-07-01':'2020-08-31'].mean(axis=0).index,rt.loc['2020-07-01':'2020-08-31'].mean(axis=0).values])
rtM78=rtM78.T.copy()
rtM78.columns=['County','RtM78']

############### Mean of Rt3 along the whole time series###############
rt3M=pd.DataFrame([rt3.mean(axis=0).index,rt3.mean(axis=0).values])
rt3M=rt3M.T.copy()
rt3M.columns=['County','Rt3M']

############### Mean of Rt3 in Jul and Aug ###############
rt3M78=pd.DataFrame([rt3.loc['2020-07-01':'2020-08-31'].mean(axis=0).index,rt3.loc['2020-07-01':'2020-08-31'].mean(axis=0).values])
rt3M78=rt3M78.T.copy()
rt3M78.columns=['County','Rt3M78']


R=pd.merge(rtM,rt3M)
RR=pd.merge(rtM78,rt3M78)
R=pd.merge(R,RR)
Var=pd.merge(popDensity,R,left_on='County',right_on='County')
#R=R.join(popDensity)
Var

import matplotlib.pyplot as plt
import plotly.express as px
import seaborn as sns
import statsmodels.api as sm
import numpy as  np

fig = plt.figure(figsize=(8,7))


for pos,key in enumerate(Var.keys()[2:]):
  X = Var['Value']
  Y = np.array(Var[key], dtype=float)
  ax1 = fig.add_subplot(2,2,pos+1)
  sns.regplot(x=X, y=Y,lowess=True,color='blue',line_kws={"color":"red"})
  ax1.set_xlabel("Population Desity / log(# per square mile)")
  ax1.set_ylabel(key)
  #ax1.title.set_text(key)

fig.savefig('Rt.pdf')

#--------------To conduct Chi Square test using contingency---------------
tb = pd.crosstab(index=Var["Value"].round(0), 
                           columns=Var["Rt3M"].astype(int))
print(tb)
from scipy.stats import chi2_contingency
tt=chi2_contingency(tb)
tt

#---------------To conduct ANOVA test----------------
from scipy.stats import f_oneway
Var['Rt3M_int']=Var['Rt3M'].astype(int)
gp=Var.groupby('Rt3M_int')
#for group in gp:
  #print(group)

f_oneway(Var[Var["Rt3M_int"]==1]['Value'].values,Var[Var["Rt3M_int"]==2]['Value'].values,
         Var[Var["Rt3M_int"]==3]['Value'].values,Var[Var["Rt3M_int"]==4]['Value'].values)

#---------------To conduct T test----------------
from scipy import stats
for i in range(1,4):

  for j in range(i+1,len(gp)):
    print(i)
    print(j)
    print(stats.ttest_ind(Var[Var["Rt3M_int"]==i]['Value'].values,Var[Var["Rt3M_int"]==j]['Value'].values))

#---------------To check pearson correlation----------------
from scipy import stats
stats.pearsonr(Var['Value'], Var['Rt3M'])

import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation
from matplotlib import rc
from IPython.display import HTML


Counties = rt3.keys()


fig = plt.figure()
ax=plt.gca()
ax.title.set_text('Nueces County Rt')
curve1, = plt.plot(rt3.T.keys(),rt3['Nueces'],label= 'Rt3',color='deeppink')
ax.legend(ncol=3)
plt.axvline(x=datetime(2020, 7, 1).date(),color='gray')

plt.ylim(0,10)
def update(i):
#     print('i:', i)
  
  curve1.set_data(rt3.T.keys(),rt3[Counties[i]])
  ax.title.set_text( Counties[i]+' County Cases')
  return curve1

anim = FuncAnimation(fig, update, frames=len(Counties),blit=False, interval=240)
plt.close()  # Closing the plot will make it not print the last frame of the plot.  So the next lin will be the only animation.

HTML(anim.to_html5_video())